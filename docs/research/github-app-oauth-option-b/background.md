# Research: GitHub App OAuth (Option B) for Android Mobile App

**Date:** 2026-02-13
**Description:** Research how to implement GitHub App OAuth for an Android mobile app where each phone is a self-contained independent client pushing to a GitHub repo. The user taps a link, gets taken to GitHub, picks a single repo, and the app gets read/write access to ONLY that repo via a user access token stored on-device.

## Sources

[1]: https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/generating-a-user-access-token-for-a-github-app "Generating a user access token for a GitHub App - GitHub Docs"
[2]: https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps "Authorizing OAuth apps - GitHub Docs"
[3]: https://nango.dev/blog/github-app-vs-github-oauth "GitHub App vs. GitHub OAuth: When to Use Which? - Nango Blog"
[4]: https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/differences-between-github-apps-and-oauth-apps "Differences between GitHub Apps and OAuth apps - GitHub Docs"
[5]: https://northflank.com/blog/integrating-with-github-github-apps-and-oauth "Integrating with GitHub - GitHub Apps and OAuth - Northflank Blog"
[6]: https://docs.github.com/en/apps/creating-github-apps/registering-a-github-app/registering-a-github-app "Registering a GitHub App - GitHub Docs"
[7]: https://www.oauth.com/oauth2-servers/oauth-native-apps/redirect-urls-for-native-apps/ "Redirect URLs for Native Apps - OAuth 2.0 Simplified"
[8]: https://docs.github.com/en/apps/creating-github-apps/registering-a-github-app/about-the-user-authorization-callback-url "About the user authorization callback URL - GitHub Docs"
[9]: https://github.com/openid/AppAuth-Android "AppAuth-Android - GitHub"
[10]: https://github.com/orgs/community/discussions/61238 "How to customize the redirect URL when registering a Github App? - GitHub Community"
[11]: https://developer.android.com/training/app-links/configure-assetlinks "Configure website associations - Android Developers"
[12]: https://blog.jakelee.co.uk/associate-android-app-links-with-your-subdomain-using-github-pages-cloudflare/ "Associate Android App Links with GitHub Pages - Jake Lee"
[13]: https://developer.okta.com/blog/2019/01/22/oauth-api-keys-arent-safe-in-mobile-apps "Why OAuth API Keys and Secrets Aren't Safe in Mobile Apps - Okta"
[14]: https://www.oauth.com/oauth2-servers/pkce/ "Protecting Apps with PKCE - OAuth 2.0 Simplified"
[15]: https://approov.io/blog/strengthening-oauth2-for-mobile "Enhancing Mobile Security: Strengthening OAuth2 with App Attestation"
[16]: https://auth0.com/blog/oauth-2-best-practices-for-native-apps/ "OAuth 2.0 Best Practices for Native Apps - Auth0"
[17]: https://docs.github.com/en/apps/creating-github-apps/registering-a-github-app/choosing-permissions-for-a-github-app "Choosing permissions for a GitHub App - GitHub Docs"
[18]: https://www.zonca.dev/posts/2025-01-29-github-auth-browser-device-flow "Authenticate to GitHub in the Browser with the Device Flow"
[19]: https://docs.github.com/en/apps/creating-github-apps/writing-code-for-a-github-app/building-a-cli-with-a-github-app "Building a CLI with a GitHub App - GitHub Docs"
[20]: https://openid.github.io/AppAuth-Android/ "AppAuth for Android - OpenID"
[21]: https://joebirch.co/android/oauth-on-android-with-custom-tabs/ "Performing OAuth on Android with Custom Tabs - Joe Birch"
[22]: https://medium.com/androiddevelopers/authenticating-on-android-with-the-appauth-library-7bea226555d5 "Authenticating on Android with the AppAuth Library - Medium"
[23]: https://www.kmaschta.me/blog/2017/03/04/github-oauth-authentication-without-server "GitHub OAuth authentication for SPA without server"
[24]: https://dimiterpetrov.com/blog/github-oauth-authorization-with-serverless-functions/ "GitHub OAuth authorization with serverless functions"
[25]: https://developer.chrome.com/docs/android/custom-tabs/guide-auth-tab "Auth Tab for Chrome Custom Tabs - Chrome Developers"
[26]: https://github.com/GoogleChrome/android-browser-helper/issues/274 "Custom Tab OAuth redirect issue - GitHub"
[27]: https://docs.github.com/en/apps/creating-github-apps/authenticating-with-a-github-app/refreshing-user-access-tokens "Refreshing user access tokens - GitHub Docs"
[28]: https://github.com/geniushkg/github-oauth "github-oauth Android library"

## Research Log

<!-- Each search entry is appended chronologically below -->

---

### Search: "GitHub App OAuth user access token flow mobile app 2025 2026"

Key finding: **GitHub Apps are preferred over OAuth Apps** for this use case because they use fine-grained permissions, give more control over which repositories the app can access, and use short-lived tokens ([GitHub Docs][4]).

**User access tokens** are a type of OAuth token generated by GitHub Apps. Unlike traditional OAuth tokens, they do **not use scopes** — instead they use fine-grained permissions set on the GitHub App configuration ([GitHub Docs][1]).

**PKCE is strongly recommended** for public clients (native apps that run on user devices). GitHub supports `S256` code challenge method only — `plain` is not supported ([GitHub Docs][1]).

#### Web Application Flow (from GitHub Docs):

**Step 1 — Authorization Request:**
- URL: `https://github.com/login/oauth/authorize`
- Required params: `client_id`
- Strongly recommended: `redirect_uri`, `state`, `code_challenge`, `code_challenge_method` (must be `S256`)
- Optional: `login`, `allow_signup`, `prompt` (set to `select_account` to force account picker)

**Step 2 — GitHub redirects back** to registered callback URL with `code` query parameter (and `state` if provided).

**Step 3 — Token Exchange:**
- POST to: `https://github.com/login/oauth/access_token`
- Required: `client_id`, `client_secret`, `code`
- Strongly recommended: `code_verifier` (for PKCE)
- Optional: `redirect_uri`, **`repository_id`** (restrict token to single repository!)

**Token Response:**
- `access_token`: Begins with `ghu_`
- **`expires_in`: 28,800 seconds (8 hours)** by default
- `refresh_token`: Begins with `ghr_`; **expires after 6 months**
- `refresh_token_expires_in`: 15,897,600 seconds
- `token_type`: `bearer`
- `scope`: Always empty string (permissions-based)

**Critical finding: `repository_id` parameter** in token exchange can restrict the token to a single repository. This is exactly what we need.

**Token expiration is opt-in** — needs to be activated in GitHub App settings. When enabled, tokens expire after 8 hours with 6-month refresh tokens ([GitHub Docs][1]).

**Callback URL behavior:** If `redirect_uri` is specified in the authorization request, that URL is used. Otherwise, the first callback URL on the app's settings page is used. The redirect_uri must match exactly — cannot contain additional parameters ([GitHub Docs][1]).

**Follow-up questions:**
- How exactly does the GitHub App installation + repo selection flow work? Is it separate from the OAuth authorization?
- How to handle the HTTPS callback URL requirement for Android apps?
- What are the details of the `repository_id` parameter?

---

### Search: "GitHub App installation flow repo selection combined with OAuth authorization"

**Installation vs. Authorization — Two Separate Concepts:**
- **Installation** = the user grants the app access to specific repos (or all repos). Each user/org gets its own installation with its own installation ID.
- **Authorization (OAuth)** = the user authorizes the app to act on their behalf, generating a user access token.

**Combined flow option:** GitHub App settings have a checkbox **"Request user authorization (OAuth) during installation"**. When enabled, after the user installs the app and selects repos, GitHub immediately starts the OAuth web application flow — redirecting to `https://github.com/login/oauth/authorize` and then to the callback URL with a `code` parameter ([GitHub Docs][6], [Northflank][5]).

**The combined flow is the key UX win:** The user goes through one flow where they:
1. Choose which account to install on
2. Select which repos the app can access (all or specific ones)
3. Authorize the app (OAuth consent)
4. Get redirected back to the callback URL with the authorization code

**The awkward alternative:** Splitting installation and OAuth into two separate user-facing flows is confusing and adds friction ([Northflank][5]).

**GitHub App Registration Settings that matter:**
- **Callback URL:** Up to 10 URLs for post-authorization redirects ([GitHub Docs][8])
- **Setup URL:** Redirects users after installation for additional configuration
- **"Request user authorization (OAuth) during installation"** checkbox — enables combined flow
- **Device Flow:** Can be enabled as alternative for user access token generation
- **"Expire user authorization tokens"** — GitHub recommends keeping this enabled
- **Permissions:** Set minimum necessary (read-only, read & write, or no access)
- **Installation scope:** "Only on this account" for private use, or "Any account" for public

**Follow-up questions:**
- What exactly is the user experience during the combined install+authorize flow?
- Does the repo selection during installation constrain what the user access token can do?
- How does the Device Flow work as an alternative?

---

### Search: "Android OAuth callback URL HTTPS redirect custom scheme GitHub deep link App Links"

**GitHub only supports HTTPS callback URLs** — custom URI schemes (like `com.myapp://callback`) are NOT supported by GitHub OAuth. This is a critical constraint for native Android apps. ([GitHub Community][10], [AppAuth-Android][9])

**Three approaches for native app OAuth redirects** (from OAuth 2.0 spec guidance, [OAuth.com][7]):

1. **HTTPS App-Claimed URLs (Recommended):** Android App Links let an HTTPS URL open a native app instead of the browser. Requires hosting a `assetlinks.json` file on the verified domain. Most secure approach — "provides the most integrity that the app belongs to the URL it's matching."

2. **Custom URI Schemes:** Less secure, no global registry for conflict avoidance. Use reverse domain name pattern. **GitHub does not support this approach.**

3. **Loopback Interface:** For desktop apps. Not applicable for mobile.

**The fundamental problem:** GitHub requires HTTPS callback URLs, but we need the redirect to land in the Android app, not a web page.

**Follow-up questions:**
- How exactly do Android App Links work for OAuth callbacks?
- Can we use a GitHub Pages site as the callback URL domain?
- What about using a simple static page that does a JavaScript redirect to a custom scheme?

---

### Search: "GitHub Pages static redirect page OAuth mobile app callback"

**GitHub Pages as redirect intermediary:** Since GitHub only accepts HTTPS callback URLs, a static GitHub Pages site could act as the bridge:

1. GitHub redirects to `https://youruser.github.io/app/callback?code=xxx&state=yyy`
2. The page has JavaScript that redirects to a custom URI scheme: `myapp://callback?code=xxx&state=yyy`
3. Android intercepts the custom scheme and opens the app

**OR** with Android App Links:

1. GitHub redirects to `https://youruser.github.io/app/callback?code=xxx&state=yyy`
2. The domain is verified via `assetlinks.json` hosted on GitHub Pages
3. Android directly opens the app without loading the page

**Redirect methods for GitHub Pages:**
- `<meta http-equiv="refresh" content="0; url=...">` — works even if JavaScript is disabled
- `window.location.href = "..."` — more flexible, can construct the redirect URL dynamically
- Jekyll redirect plugin

**Key insight:** The JavaScript redirect approach is simpler because it doesn't require the full App Links verification (no need for `assetlinks.json`). But it means the page briefly loads in the browser before redirecting. App Links would be seamless but require hosting the verification file.

**Follow-up questions:**
- Does Android App Links verification work with GitHub Pages?
- How exactly does `assetlinks.json` work?
- What about the "during installation" combined flow — does that change the callback URL behavior?

---

### Search: "Android App Links assetlinks.json GitHub Pages hosting OAuth callback verification"

**Android App Links with GitHub Pages is a proven approach** ([Jake Lee][12]):

**Setup steps:**
1. Generate `assetlinks.json` using Android Studio's App Links Assistant (Tools > App Links Assistant > Associate website). Needs domain, package name, signing certificate fingerprint.
2. Create GitHub Pages repo with `/.well-known/assetlinks.json`
3. **Critical gotcha:** Must create `_config.yml` with `include: [".well-known"]` — GitHub Pages hides dotfiles by default ([Jake Lee][12])
4. Enable HTTPS on the GitHub Pages site
5. Verify with Google's Asset Linking API
6. Add intent filter with `android:autoVerify="true"` to Android manifest

**Requirements for `assetlinks.json`** ([Android Developers][11]):
- Must be publicly available (not behind VPN)
- Must be served with `Content-type: application/json`
- Must be accessible over HTTPS
- Must return HTTP 200 directly (no redirects)

**Format:**
```json
[{
  "relation": ["delegate_permission/common.handle_all_urls"],
  "target": {
    "namespace": "android_app",
    "package_name": "com.example.app",
    "sha256_cert_fingerprints": ["AA:BB:CC:..."]
  }
}]
```

**This means GitHub Pages + App Links is the zero-backend solution:** Host `assetlinks.json` and a fallback HTML page on GitHub Pages. Register the GitHub Pages URL as the callback URL in the GitHub App. Android opens the app directly via App Links; if App Links fails (old Android, unverified), the HTML page redirects via JavaScript.

**Follow-up questions:**
- What about Custom Tabs behavior with App Links?
- Does the redirect from GitHub OAuth work seamlessly with App Links?

---

### Search: "OAuth client_secret in mobile APK security risk PKCE protection public client native app"

**Client secret in APK is fundamentally insecure** ([Okta][13]):
- API keys embedded in mobile app binaries are **trivially extractable** using the `strings` command on compiled apps
- Even HTTPS traffic can be intercepted using Charles Proxy or mitmproxy with a custom CA certificate installed on the device
- Historical precedent: 2013 Twitter API key leak — official app secrets extracted from binaries, allowing attackers to impersonate the legitimate application

**Native apps are "public clients"** — they cannot protect static secrets. The `client_secret` shipped in an APK is the same for all users and devices, making it a shared secret that's easily compromised ([Okta][13], [Auth0][16]).

**What PKCE protects against** ([OAuth.com][14]):
- PKCE generates a **new random secret for every OAuth flow** — no pre-shipped secrets
- Prevents **authorization code interception attacks**: even if an attacker intercepts the `code` during the redirect, they cannot exchange it for a token without the `code_verifier` (which stays on the device that initiated the flow)
- PKCE is specifically designed for public clients where client_secret cannot be kept confidential

**The GitHub-specific situation:**
- GitHub **still requires `client_secret`** in the token exchange, even when PKCE is used
- This is a deviation from the pure PKCE model where client_secret would be unnecessary
- The practical risk: someone extracts client_secret from APK, but they still cannot complete the flow without the PKCE code_verifier AND the authorization code (which requires user interaction)
- **PKCE + client_secret together** provides defense in depth: client_secret alone is not enough, and an intercepted code is not enough

**Additional mitigations for mobile apps** ([Approov][15]):
- App attestation services can verify the app's authenticity at runtime
- Short-lived tokens (8-hour expiry) limit the blast radius of any token compromise
- Refresh token rotation detects and prevents token replay attacks

**Follow-up questions:**
- Does GitHub's requirement for client_secret even with PKCE create real risk beyond theoretical?
- Are there any alternatives to shipping client_secret in the APK?

---

### Search: "GitHub OAuth device flow mobile app user access token how it works step by step"

**Device Flow as alternative to web application flow** — useful when the app doesn't have convenient browser access or when the callback URL problem is too painful ([GitHub Docs][1], [Zonca][18]):

**Step-by-step:**
1. **Request device and user codes:** POST to `https://github.com/login/device/code` with `client_id` and `scope` (though for GitHub Apps, scope isn't used)
2. **Display user code:** Show the user a short code and direct them to `https://github.com/login/device`
3. **User enters code in browser:** They visit the URL, enter the code, and authorize the app
4. **App polls for authorization:** POST to `https://github.com/login/oauth/access_token` with `client_id`, `device_code`, and `grant_type=urn:ietf:params:oauth:grant-type:device_code`
5. **Receive access token:** Once user authorizes, the polling returns the token

**Key advantages for mobile:**
- **No callback URL needed at all** — eliminates the HTTPS redirect problem entirely
- **No client_secret required** — the device flow doesn't need it
- Works for headless/CLI apps

**Key disadvantages:**
- **Worse UX:** User has to manually visit a URL and enter a code (or scan a QR code)
- **No combined install+authorize flow:** Cannot use "Request user authorization during installation"
- **Polling is clunky:** App must poll every N seconds until user completes the flow
- User might not complete the flow (codes expire)

**For this use case:** Device flow avoids the callback URL and client_secret problems entirely but at the cost of user experience. The user would need to: open browser, go to github.com/login/device, enter the code, authorize. More steps than a seamless redirect-based flow.

---

### Search: "GitHub App user access token permissions intersection installation repo selection scope"

**Permission model is an intersection** ([GitHub Docs][1], [GitHub Docs][17]):

> A user access token only has permissions that both the user and the app have.

**Three layers of access control:**
1. **GitHub App permissions** — configured when registering the app (e.g., Contents: Read & Write). This is the ceiling.
2. **Installation repo selection** — when the user installs the app, they choose which repos it can access (all repos, or specific repos). This limits the scope.
3. **User's own permissions** — the user must have at least the level of access being requested. If the app has write access but the user only has read access to a repo, the token can only read.

**The result:** The user access token can only access repos that are in the intersection of:
- Repos the user has access to
- Repos the installation was granted access to
- With the minimum of the app's permissions and the user's permissions

**Critical for our use case:** If the user installs the app and selects only one repo, the user access token can only access that one repo. **Plus**, we can further restrict it by passing `repository_id` during token exchange ([GitHub Docs][1]).

**Double restriction = belt and suspenders:** Installation limits repos, `repository_id` parameter during token exchange further narrows to exactly one.

---

### Search: "Android Custom Tabs OAuth flow AppAuth library GitHub authentication example Kotlin"

**AppAuth-Android** is the recommended library for OAuth on Android ([AppAuth][20]):
- Follows OAuth 2.0 best practices for native apps (RFC 8252)
- Uses Custom Tabs for auth requests (Chrome Custom Tabs preferred)
- Falls back to default browser if Custom Tabs unavailable
- **WebView explicitly NOT supported** — security and usability reasons
- Supports both Custom URI Schemes and App Links (API 23+) for redirects
- Supports PKCE extension

**How Custom Tabs work for OAuth** ([Joe Birch][21]):
- App launches a Custom Tab with the authorization URL
- Custom Tab shows GitHub's login/authorization UI
- After authorization, GitHub redirects to callback URL
- If App Links is set up, Android intercepts the redirect and opens the app
- If not, the page loads and can use JavaScript to redirect to a custom scheme

**AppAuth flow in Android (high-level)** ([Medium][22]):
1. Create `AuthorizationServiceConfiguration` with auth and token endpoints
2. Build `AuthorizationRequest` with client_id, redirect_uri, PKCE parameters
3. Launch auth intent via `AuthorizationService.getAuthorizationRequestIntent()`
4. Receive result in activity via intent filter
5. Exchange code for token using `AuthorizationService.performTokenRequest()`

**GitHub-specific note:** GitHub doesn't support OpenID Connect discovery, so you can't use auto-configuration. Must manually specify endpoints.

---

### Search: "Android app GitHub OAuth without backend server"

**True client-only GitHub OAuth without any backend is not recommended** ([Kmaschta][23]):
- GitHub only supports Authorization Code Grant (not Implicit Grant)
- The token exchange step requires `client_secret`, which shouldn't be in client-side code
- GitHub's design assumes a backend server handles the secret exchange

**Practical approaches for "no backend" or "minimal backend":**

1. **Ship client_secret in APK + PKCE** — technically works, GitHub doesn't block it. The secret is extractable but PKCE + user interaction requirements limit real-world exploitation. Many Android apps do this despite it being against best practice.

2. **Serverless function as proxy** — a minimal Lambda/Cloud Function that only does the token exchange step. Keeps client_secret server-side. Very lightweight "backend" ([Petrov][24]).

3. **Device Flow** — no client_secret or callback URL needed at all. Worse UX but cleanest security model for client-only apps.

**Key insight for our use case:** Option 1 (ship secret in APK) is the simplest and works. The security risk is real but bounded — an attacker who extracts the secret still needs user interaction to get tokens, and those tokens are scoped to the user's repos. The client_secret does not grant access to any user data by itself.

---

### Search: "Chrome Custom Tabs App Links redirect intercepted OAuth intent filter Android behavior"

**Critical gotcha: Custom Tabs + App Links redirect interception has known issues** ([Chrome Issue][26]):

- Chrome Custom Tabs historically had bugs where HTTPS redirects to App Links-verified URLs would **not** properly launch the app and instead stay in the browser tab
- Chrome 72 introduced a breaking change where Custom Tab redirects stopped working with App Links in some scenarios
- Multiple AppAuth-Android issues document this problem

**New solution: Chrome Auth Tab (Chrome 137+, Jan 2025)** ([Chrome Developers][25]):
- A new specialized Custom Tab specifically for OAuth authentication
- **Handles HTTPS redirects natively** — uses Digital Asset Links verification to capture redirects
- No need for intent filters in AndroidManifest for the redirect capture
- API: `AuthTabIntent.Builder` with `launch(redirectHost, redirectPath)` for HTTPS redirects
- Falls back gracefully to regular Custom Tabs on older Chrome versions via `CustomTabsClient.isAuthTabSupported()`
- Removes unnecessary browser UI (bookmarks, downloads, share) for a focused auth experience

**Practical implications for our implementation:**
- Auth Tab is the cleanest solution for Chrome 137+ (rolling out since Jan 2025)
- For older devices, need a fallback: either regular Custom Tabs with App Links (somewhat unreliable) or JavaScript redirect on the callback page
- The safest strategy: use App Links + a JavaScript fallback page hosted on GitHub Pages

---

### Search: "GitHub App OAuth token refresh endpoint how to refresh expired user access token"

**Token refresh flow** ([GitHub Docs][27]):

POST to: `https://github.com/login/oauth/access_token`
Parameters:
- `client_id` — required
- `client_secret` — required
- `grant_type` — must be `"refresh_token"`
- `refresh_token` — the refresh token from the original token exchange

**Response:** New access token + new refresh token. **The old refresh token is invalidated** (rotation).

**Key lifecycle details:**
- Access token: expires in **8 hours** (when expiration is enabled)
- Refresh token: expires in **6 months**
- Once a refresh token is used, it's invalidated — you get a new one each time (token rotation)
- If the refresh token expires before being used, the user must re-authorize through the full flow

**What the app needs to store:**
- `access_token` (ghu_...) — for API calls
- `refresh_token` (ghr_...) — for renewal
- `expires_in` / expiration timestamp — to know when to refresh
- `client_id` — for refresh requests
- `client_secret` — for refresh requests (must be in the app)
